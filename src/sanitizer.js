// Copyright (C) 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview
 * An HTML sanitizer that can satisfy a variety of security policies.
 *
 * <p>
 * The HTML sanitizer is built around a SAX parser and HTML element and
 * attributes schemas.
 *
 * If the cssparser is loaded, inline styles are sanitized using the
 * css property and value schemas.  Else they are remove during
 * sanitization.
 *
 * If it exists, uses parseCssDeclarations, sanitizeCssProperty,  cssSchema
 *
 * @author mikesamuel@gmail.com
 * @author jasvir@gmail.com
 * \@requires html4, URI
 * \@overrides window
 * \@provides html, html_sanitize
 */

/* Copyright Google Inc.
 * Licensed under the Apache Licence Version 2.0
 * Autogenerated at Fri Aug 13 11:26:55 PDT 2010
 * @provides html4
 */
var html4 = {};
html4 .atype = {
    'NONE': 0,
    'URI': 1,
    'URI_FRAGMENT': 11,
    'SCRIPT': 2,
    'STYLE': 3,
    'ID': 4,
    'IDREF': 5,
    'IDREFS': 6,
    'GLOBAL_NAME': 7,
    'LOCAL_NAME': 8,
    'CLASSES': 9,
    'FRAME_TARGET': 10
};
html4 .ATTRIBS = {
    '*::class': 9,
    '*::dir': 0,
    '*::id': 4,
    '*::lang': 0,
    '*::onclick': 2,
    '*::ondblclick': 2,
    '*::onkeydown': 2,
    '*::onkeypress': 2,
    '*::onkeyup': 2,
    '*::onload': 2,
    '*::onmousedown': 2,
    '*::onmousemove': 2,
    '*::onmouseout': 2,
    '*::onmouseover': 2,
    '*::onmouseup': 2,
    '*::style': 3,
    '*::title': 0,
    'a::accesskey': 0,
    'a::coords': 0,
    'a::href': 1,
    'a::hreflang': 0,
    'a::name': 7,
    'a::onblur': 2,
    'a::onfocus': 2,
    'a::rel': 0,
    'a::rev': 0,
    'a::shape': 0,
    'a::tabindex': 0,
    'a::target': 10,
    'a::type': 0,
    'area::accesskey': 0,
    'area::alt': 0,
    'area::coords': 0,
    'area::href': 1,
    'area::nohref': 0,
    'area::onblur': 2,
    'area::onfocus': 2,
    'area::shape': 0,
    'area::tabindex': 0,
    'area::target': 10,
    'bdo::dir': 0,
    'blockquote::cite': 1,
    'br::clear': 0,
    'button::accesskey': 0,
    'button::disabled': 0,
    'button::name': 8,
    'button::onblur': 2,
    'button::onfocus': 2,
    'button::tabindex': 0,
    'button::type': 0,
    'button::value': 0,
    'caption::align': 0,
    'col::align': 0,
    'col::char': 0,
    'col::charoff': 0,
    'col::span': 0,
    'col::valign': 0,
    'col::width': 0,
    'colgroup::align': 0,
    'colgroup::char': 0,
    'colgroup::charoff': 0,
    'colgroup::span': 0,
    'colgroup::valign': 0,
    'colgroup::width': 0,
    'del::cite': 1,
    'del::datetime': 0,
    'dir::compact': 0,
    'div::align': 0,
    'dl::compact': 0,
    'font::color': 0,
    'font::face': 0,
    'font::size': 0,
    'form::accept': 0,
    'form::action': 1,
    'form::autocomplete': 0,
    'form::enctype': 0,
    'form::method': 0,
    'form::name': 7,
    'form::onreset': 2,
    'form::onsubmit': 2,
    'form::target': 10,
    'h1::align': 0,
    'h2::align': 0,
    'h3::align': 0,
    'h4::align': 0,
    'h5::align': 0,
    'h6::align': 0,
    'hr::align': 0,
    'hr::noshade': 0,
    'hr::size': 0,
    'hr::width': 0,
    'iframe::align': 0,
    'iframe::frameborder': 0,
    'iframe::height': 0,
    'iframe::marginheight': 0,
    'iframe::marginwidth': 0,
    'iframe::width': 0,
    'img::align': 0,
    'img::alt': 0,
    'img::border': 0,
    'img::height': 0,
    'img::hspace': 0,
    'img::ismap': 0,
    'img::name': 7,
    'img::src': 1,
    'img::usemap': 11,
    'img::vspace': 0,
    'img::width': 0,
    'input::accept': 0,
    'input::accesskey': 0,
    'input::align': 0,
    'input::alt': 0,
    'input::autocomplete': 0,
    'input::checked': 0,
    'input::disabled': 0,
    'input::ismap': 0,
    'input::maxlength': 0,
    'input::name': 8,
    'input::onblur': 2,
    'input::onchange': 2,
    'input::onfocus': 2,
    'input::onselect': 2,
    'input::readonly': 0,
    'input::size': 0,
    'input::src': 1,
    'input::tabindex': 0,
    'input::type': 0,
    'input::usemap': 11,
    'input::value': 0,
    'ins::cite': 1,
    'ins::datetime': 0,
    'label::accesskey': 0,
    'label::for': 5,
    'label::onblur': 2,
    'label::onfocus': 2,
    'legend::accesskey': 0,
    'legend::align': 0,
    'li::type': 0,
    'li::value': 0,
    'map::name': 7,
    'menu::compact': 0,
    'ol::compact': 0,
    'ol::start': 0,
    'ol::type': 0,
    'optgroup::disabled': 0,
    'optgroup::label': 0,
    'option::disabled': 0,
    'option::label': 0,
    'option::selected': 0,
    'option::value': 0,
    'p::align': 0,
    'pre::width': 0,
    'q::cite': 1,
    'select::disabled': 0,
    'select::multiple': 0,
    'select::name': 8,
    'select::onblur': 2,
    'select::onchange': 2,
    'select::onfocus': 2,
    'select::size': 0,
    'select::tabindex': 0,
    'table::align': 0,
    'table::bgcolor': 0,
    'table::border': 0,
    'table::cellpadding': 0,
    'table::cellspacing': 0,
    'table::frame': 0,
    'table::rules': 0,
    'table::summary': 0,
    'table::width': 0,
    'tbody::align': 0,
    'tbody::char': 0,
    'tbody::charoff': 0,
    'tbody::valign': 0,
    'td::abbr': 0,
    'td::align': 0,
    'td::axis': 0,
    'td::bgcolor': 0,
    'td::char': 0,
    'td::charoff': 0,
    'td::colspan': 0,
    'td::headers': 6,
    'td::height': 0,
    'td::nowrap': 0,
    'td::rowspan': 0,
    'td::scope': 0,
    'td::valign': 0,
    'td::width': 0,
    'textarea::accesskey': 0,
    'textarea::cols': 0,
    'textarea::disabled': 0,
    'textarea::name': 8,
    'textarea::onblur': 2,
    'textarea::onchange': 2,
    'textarea::onfocus': 2,
    'textarea::onselect': 2,
    'textarea::readonly': 0,
    'textarea::rows': 0,
    'textarea::tabindex': 0,
    'tfoot::align': 0,
    'tfoot::char': 0,
    'tfoot::charoff': 0,
    'tfoot::valign': 0,
    'th::abbr': 0,
    'th::align': 0,
    'th::axis': 0,
    'th::bgcolor': 0,
    'th::char': 0,
    'th::charoff': 0,
    'th::colspan': 0,
    'th::headers': 6,
    'th::height': 0,
    'th::nowrap': 0,
    'th::rowspan': 0,
    'th::scope': 0,
    'th::valign': 0,
    'th::width': 0,
    'thead::align': 0,
    'thead::char': 0,
    'thead::charoff': 0,
    'thead::valign': 0,
    'tr::align': 0,
    'tr::bgcolor': 0,
    'tr::char': 0,
    'tr::charoff': 0,
    'tr::valign': 0,
    'ul::compact': 0,
    'ul::type': 0
};
html4 .eflags = {
    'OPTIONAL_ENDTAG': 1,
    'EMPTY': 2,
    'CDATA': 4,
    'RCDATA': 8,
    'UNSAFE': 16,
    'FOLDABLE': 32,
    'SCRIPT': 64,
    'STYLE': 128
};
html4 .ELEMENTS = {
    'a': 0,
    'abbr': 0,
    'acronym': 0,
    'address': 0,
    'applet': 16,
    'area': 2,
    'b': 0,
    'base': 18,
    'basefont': 18,
    'bdo': 0,
    'big': 0,
    'blockquote': 0,
    'body': 49,
    'br': 2,
    'button': 0,
    'caption': 0,
    'center': 0,
    'cite': 0,
    'code': 0,
    'col': 2,
    'colgroup': 1,
    'dd': 1,
    'del': 0,
    'dfn': 0,
    'dir': 0,
    'div': 0,
    'dl': 0,
    'dt': 1,
    'em': 0,
    'fieldset': 0,
    'font': 0,
    'form': 0,
    'frame': 18,
    'frameset': 16,
    'h1': 0,
    'h2': 0,
    'h3': 0,
    'h4': 0,
    'h5': 0,
    'h6': 0,
    'head': 49,
    'hr': 2,
    'html': 49,
    'i': 0,
    'iframe': 4,
    'img': 2,
    'input': 2,
    'ins': 0,
    'isindex': 18,
    'kbd': 0,
    'label': 0,
    'legend': 0,
    'li': 1,
    'link': 18,
    'map': 0,
    'menu': 0,
    'meta': 18,
    'noframes': 20,
    'noscript': 20,
    'object': 16,
    'ol': 0,
    'optgroup': 0,
    'option': 1,
    'p': 1,
    'param': 18,
    'pre': 0,
    'q': 0,
    's': 0,
    'samp': 0,
    'script': 84,
    'select': 0,
    'small': 0,
    'span': 0,
    'strike': 0,
    'strong': 0,
    'style': 148,
    'sub': 0,
    'sup': 0,
    'table': 0,
    'tbody': 1,
    'td': 1,
    'textarea': 8,
    'tfoot': 1,
    'th': 1,
    'thead': 1,
    'title': 24,
    'tr': 1,
    'tt': 0,
    'u': 0,
    'ul': 0,
    'var': 0
};

html4 .URIEFFECTS = {
    NEW_DOCUMENT: {
        "FORM::ACTION": ""
{ "key": "CAPTION::ALIGN", "description": "relative to table",
    "optional": true },
{ "key": "APPLET::ALIGN", "description": "vertical or horizontal alignment",
    "optional": true },
{ "key": "IFRAME::ALIGN", "description": "vertical or horizontal alignment",
    "optional": true },
{ "key": "IMG::ALIGN", "description": "vertical or horizontal alignment",
    "optional": true },
{ "key": "INPUT::ALIGN", "description": "vertical or horizontal alignment",
    "optional": true },
{ "key": "OBJECT::ALIGN", "description": "vertical or horizontal alignment",
    "optional": true },
{ "key": "LEGEND::ALIGN", "description": "relative to fieldset",
    "optional": true },
{ "key": "TABLE::ALIGN", "description": "table position relative to window",
    "optional": true },
{ "key": "HR::ALIGN",
    "values": "left,center,right", "optional": true },
{ "key": "DIV::ALIGN", "description": "align, text alignment",
    "values": "left,center,right,justify", "optional": true },
{ "key": "H1::ALIGN", "description": "align, text alignment",
    "values": "left,center,right,justify", "optional": true },
{ "key": "H2::ALIGN", "description": "align, text alignment",
    "values": "left,center,right,justify", "optional": true },
{ "key": "H3::ALIGN", "description": "align, text alignment",
    "values": "left,center,right,justify", "optional": true },
{ "key": "H4::ALIGN", "description": "align, text alignment",
    "values": "left,center,right,justify", "optional": true },
{ "key": "H5::ALIGN", "description": "align, text alignment",
    "values": "left,center,right,justify", "optional": true },
{ "key": "H6::ALIGN", "description": "align, text alignment",
    "values": "left,center,right,justify", "optional": true },
{ "key": "P::ALIGN", "description": "align, text alignment",
    "values": "left,center,right,justify", "optional": true },
{ "key": "COL::ALIGN",
    "values": "left,center,right,justify,char", "optional": true },
{ "key": "COLGROUP::ALIGN",
    "values": "left,center,right,justify,char", "optional": true },
{ "key": "TBODY::ALIGN",
    "values": "left,center,right,justify,char", "optional": true },
{ "key": "TD::ALIGN",
    "values": "left,center,right,justify,char", "optional": true },
{ "key": "TFOOT::ALIGN",
    "values": "left,center,right,justify,char", "optional": true },
{ "key": "TH::ALIGN",
    "values": "left,center,right,justify,char", "optional": true },
{ "key": "THEAD::ALIGN",
    "values": "left,center,right,justify,char", "optional": true },
{ "key": "TR::ALIGN",
    "values": "left,center,right,justify,char", "optional": true },
{ "key": "BODY::ALINK", "description": "color of selected links",
    "pattern": "\\w+|#[0-9A-Fa-f]{6}", "optional": true },
{ "key": "APPLET::ALT", "description": "short description",
    "optional": true },
{ "key": "AREA::ALT", "description": "short description",
    "optional": true },
{ "key": "IMG::ALT", "description": "short description",
    "optional": true },
{ "key": "INPUT::ALT", "description": "short description",
    "optional": true },
{ "key": "APPLET::ARCHIVE", "description": "comma-separated archive list",
    "optional": true },
{ "key": "OBJECT::ARCHIVE", "description": "space-separated list of URIs",
    "optional": true },
{ "key": "TD::AXIS", "description": "comma-separated list of related headers",
    "optional": true },
{ "key": "TH::AXIS", "description": "comma-separated list of related headers",
    "optional": true },
{ "key": "BODY::BACKGROUND", "description": "texture tile for document background",
    "mimeTypes": "image/*", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT",
    "loaderType": "SANDBOXED" },
{ "key": "TABLE::BGCOLOR", "description": "background color for cells",
    "pattern": "\\w+|#[0-9A-Fa-f]{6}", "optional": true },
{ "key": "TR::BGCOLOR", "description": "background color for row",
    "pattern": "\\w+|#[0-9A-Fa-f]{6}", "optional": true },
{ "key": "TD::BGCOLOR", "description": "cell background color",
    "pattern": "\\w+|#[0-9A-Fa-f]{6}", "optional": true },
{ "key": "TH::BGCOLOR", "description": "cell background color",
    "pattern": "\\w+|#[0-9A-Fa-f]{6}", "optional": true },
{ "key": "BODY::BGCOLOR", "description": "document background color",
    "pattern": "\\w+|#[0-9A-Fa-f]{6}", "optional": true },
{ "key": "TABLE::BORDER", "description": "controls frame width around table",
    "pattern": "[0-9]+", "optional": true },
{ "key": "IMG::BORDER", "description": "link border width",
    "pattern": "[0-9]+", "optional": true },
{ "key": "OBJECT::BORDER", "description": "link border width",
    "pattern": "[0-9]+", "optional": true },
{ "key": "TABLE::CELLPADDING", "description": "spacing within cells",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "TABLE::CELLSPACING", "description": "spacing between cells",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "COL::CHAR", "description": "alignment char, e.g. char=':'",
    "pattern": ".", "optional": true },
{ "key": "COLGROUP::CHAR", "description": "alignment char, e.g. char=':'",
    "pattern": ".", "optional": true },
{ "key": "TBODY::CHAR", "description": "alignment char, e.g. char=':'",
    "pattern": ".", "optional": true },
{ "key": "TD::CHAR", "description": "alignment char, e.g. char=':'",
    "pattern": ".", "optional": true },
{ "key": "TFOOT::CHAR", "description": "alignment char, e.g. char=':'",
    "pattern": ".", "optional": true },
{ "key": "TH::CHAR", "description": "alignment char, e.g. char=':'",
    "pattern": ".", "optional": true },
{ "key": "THEAD::CHAR", "description": "alignment char, e.g. char=':'",
    "pattern": ".", "optional": true },
{ "key": "TR::CHAR", "description": "alignment char, e.g. char=':'",
    "pattern": ".", "optional": true },
{ "key": "COL::CHAROFF", "description": "offset for alignment char",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "COLGROUP::CHAROFF", "description": "offset for alignment char",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "TBODY::CHAROFF", "description": "offset for alignment char",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "TD::CHAROFF", "description": "offset for alignment char",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "TFOOT::CHAROFF", "description": "offset for alignment char",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "TH::CHAROFF", "description": "offset for alignment char",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "THEAD::CHAROFF", "description": "offset for alignment char",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "TR::CHAROFF", "description": "offset for alignment char",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "A::CHARSET", "description": "char encoding of linked resource",
    "optional": true },
{ "key": "LINK::CHARSET", "description": "char encoding of linked resource",
    "optional": true },
{ "key": "SCRIPT::CHARSET", "description": "char encoding of linked resource",
    "optional": true },
{ "key": "INPUT::CHECKED", "description": "for radio buttons and check boxes",
    "values": "checked", "valueless": true, "optional": true },
{ "key": "BLOCKQUOTE::CITE", "description": "URI for source document or msg",
    "mimeTypes": "*/*", "optional": true,
    "type": "URI", "uriEffect": "NOT_LOADED", "loaderType": "UNSANDBOXED" },
{ "key": "Q::CITE", "description": "URI for source document or msg",
    "mimeTypes": "*/*", "optional": true,
    "type": "URI", "uriEffect": "NOT_LOADED", "loaderType": "UNSANDBOXED" },
{ "key": "DEL::CITE", "description": "info on reason for change",
    "mimeTypes": "*/*", "optional": true,
    "type": "URI", "uriEffect": "NOT_LOADED", "loaderType": "UNSANDBOXED" },
{ "key": "INS::CITE", "description": "info on reason for change",
    "mimeTypes": "*/*", "optional": true,
    "type": "URI", "uriEffect": "NOT_LOADED", "loaderType": "UNSANDBOXED" },
{ "key": "*::CLASS", "description": "space-separated list of classes",
    "type": "CLASSES", "optional": true },
{ "key": "OBJECT::CLASSID", "description": "identifies an implementation",
    "mimeTypes": "application/*", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT",
    "loaderType": "UNSANDBOXED" },
{ "key": "BR::CLEAR", "description": "control of text flow",
    "values": "left,all,right,none", "default": "none", "optional": true },
{ "key": "APPLET::CODE", "description": "applet class file",
    "optional": true },
{ "key": "OBJECT::CODEBASE", "description": "base URI for classid, data, archive",
    "mimeTypes": "application/*", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT",
    "loaderType": "UNSANDBOXED" },
{ "key": "APPLET::CODEBASE", "description": "optional base URI for applet",
    "mimeTypes": "application/*", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT",
    "loaderType": "UNSANDBOXED" },
{ "key": "OBJECT::CODETYPE", "description": "content type for code",
    "optional": true },
{ "key": "BASEFONT::COLOR", "description": "text color",
    "pattern": "\\w+|#[0-9A-Fa-f]{6}", "optional": true },
{ "key": "FONT::COLOR", "description": "text color",
    "pattern": "\\w+|#[0-9A-Fa-f]{6}", "optional": true },
{ "key": "FRAMESET::COLS", "description": "list of lengths, default: 100% (1 col)",
    "optional": true },
{ "key": "TEXTAREA::COLS",
    "pattern": "[0-9]+", "optional": true },
{ "key": "TD::COLSPAN", "description": "number of cols spanned by cell",
    "pattern": "[0-9]+", "default": "1", "optional": true },
{ "key": "TH::COLSPAN", "description": "number of cols spanned by cell",
    "pattern": "[0-9]+", "default": "1", "optional": true },
{ "key": "DIR::COMPACT", "description": "reduced interitem spacing",
    "values": "compact", "valueless": true, "optional": true },
{ "key": "DL::COMPACT", "description": "reduced interitem spacing",
    "values": "compact", "valueless": true, "optional": true },
{ "key": "MENU::COMPACT", "description": "reduced interitem spacing",
    "values": "compact", "valueless": true, "optional": true },
{ "key": "OL::COMPACT", "description": "reduced interitem spacing",
    "values": "compact", "valueless": true, "optional": true },
{ "key": "UL::COMPACT", "description": "reduced interitem spacing",
    "values": "compact", "valueless": true, "optional": true },
{ "key": "META::CONTENT", "description": "associated information",
    "optional": false },
{ "key": "AREA::COORDS", "description": "comma-separated list of lengths",
    "pattern": "[0-9]+(?:,[0-9]+)*", "optional": true },
{ "key": "A::COORDS", "description": "for use with client-side image maps",
    "pattern": "[0-9]+(?:,[0-9]+)*", "optional": true },
{ "key": "OBJECT::DATA", "description": "reference to object's data",
    "mimeTypes": "application/*", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT",
    "loaderType": "UNSANDBOXED" },
{ "key": "DEL::DATETIME", "description": "date and time of change",
    "optional": true },
{ "key": "INS::DATETIME", "description": "date and time of change",
    "optional": true },
{ "key": "OBJECT::DECLARE", "description": "declare but don't instantiate flag",
    "values": "declare", "valueless": true, "optional": true },
{ "key": "SCRIPT::DEFER", "description": "UA may defer execution of script",
    "values": "defer", "valueless": true, "optional": true },
{ "key": "*::DIR", "description": "direction for weak/neutral text",
    "values": "ltr,rtl", "optional": true },
{ "key": "BDO::DIR", "description": "directionality",
    "values": "ltr,rtl", "optional": false },
{ "key": "BUTTON::DISABLED", "description": "unavailable in this context",
    "values": "disabled", "valueless": true, "optional": true },
{ "key": "INPUT::DISABLED", "description": "unavailable in this context",
    "values": "disabled", "valueless": true, "optional": true },
{ "key": "OPTGROUP::DISABLED", "description": "unavailable in this context",
    "values": "disabled", "valueless": true, "optional": true },
{ "key": "OPTION::DISABLED", "description": "unavailable in this context",
    "values": "disabled", "valueless": true, "optional": true },
{ "key": "SELECT::DISABLED", "description": "unavailable in this context",
    "values": "disabled", "valueless": true, "optional": true },
{ "key": "TEXTAREA::DISABLED", "description": "unavailable in this context",
    "values": "disabled", "valueless": true, "optional": true },
{ "key": "FORM::ENCTYPE",
    "default": "application/x-www-form-urlencoded", "optional": true },
{ "key": "BASEFONT::FACE", "description": "comma-separated list of font names",
    "optional": true },
{ "key": "FONT::FACE", "description": "comma-separated list of font names",
    "optional": true },
{ "key": "LABEL::FOR", "description": "matches field ID value",
    "type": "IDREF", "optional": true },
{ "key": "TABLE::FRAME", "description": "which parts of frame to render",
    "values": "void,above,below,border,box,hsides,lhs,rhs,vsides",
    "optional": true },
{ "key": "FRAME::FRAMEBORDER", "description": "request frame borders?",
    "values": "1,0", "default": "1", "optional": true },
{ "key": "IFRAME::FRAMEBORDER", "description": "request frame borders?",
    "values": "1,0", "default": "1", "optional": true },
{ "key": "TD::HEADERS", "description": "list of id's for header cells",
    "type": "IDREFS", "optional": true },
{ "key": "TH::HEADERS", "description": "list of id's for header cells",
    "type": "IDREFS", "optional": true },
{ "key": "IFRAME::HEIGHT", "description": "frame height",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "TD::HEIGHT", "description": "height for cell",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "TH::HEIGHT", "description": "height for cell",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "IMG::HEIGHT", "description": "override height",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "OBJECT::HEIGHT", "description": "override height",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "APPLET::HEIGHT", "description": "initial height",
    "pattern": "[0-9]+%?", "optional": false },
{ "key": "A::HREF", "description": "URI for linked resource",
    "mimeTypes": "*/*", "optional": true,
    "type": "URI", "uriEffect": "NEW_DOCUMENT",
    "loaderType": "UNSANDBOXED" },
{ "key": "AREA::HREF", "description": "URI for linked resource",
    "mimeTypes": "*/*", "optional": true,
    "type": "URI", "uriEffect": "NEW_DOCUMENT",
    "loaderType": "UNSANDBOXED" },
{ "key": "LINK::HREF", "description": "URI for linked resource",
    "mimeTypes": "text/css", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT",
    "loaderType": "UNSANDBOXED" },
{ "key": "BASE::HREF", "description": "URI that acts as base URI",
    "mimeTypes": "text/html", "optional": true,
    "type": "URI", "uriEffect": "NOT_LOADED", "loaderType": "UNSANDBOXED" },
{ "key": "A::HREFLANG", "description": "language code",
    "optional": true },
{ "key": "LINK::HREFLANG", "description": "language code",
    "optional": true },
{ "key": "APPLET::HSPACE", "description": "horizontal gutter",
    "pattern": "[0-9]+", "optional": true },
{ "key": "IMG::HSPACE", "description": "horizontal gutter",
    "pattern": "[0-9]+", "optional": true },
{ "key": "OBJECT::HSPACE", "description": "horizontal gutter",
    "pattern": "[0-9]+", "optional": true },
{ "key": "META::HTTP-EQUIV", "description": "HTTP response header name",
    "optional": true },
{ "key": "*::ID", "description": "document-wide unique id",
    "type": "ID", "optional": true },
{ "key": "IMG::ISMAP", "description": "use server-side image map",
    "values": "ismap", "valueless": true, "optional": true },
{ "key": "INPUT::ISMAP", "description": "use server-side image map",
    "values": "ismap", "valueless": true, "optional": true },
{ "key": "OPTION::LABEL", "description": "for use in hierarchical menus",
    "optional": true },
{ "key": "OPTGROUP::LABEL", "description": "for use in hierarchical menus",
    "optional": false },
{ "key": "*::LANG", "description": "language code",
    "optional": true },
{ "key": "SCRIPT::LANGUAGE", "description": "predefined script language name",
    "optional": true },
{ "key": "BODY::LINK", "description": "color of links",
    "pattern": "\\w+|#[0-9A-Fa-f]{6}", "optional": true },
{ "key": "IMG::LONGDESC", "description": "link to long description (complements alt)",
    "mimeTypes": "*/*", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT", "loaderType": "DATA" },
{ "key": "FRAME::LONGDESC", "description": "link to long description (complements title)",
    "mimeTypes": "*/*", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT", "loaderType": "DATA" },
{ "key": "IFRAME::LONGDESC", "description": "link to long description (complements title)",
    "mimeTypes": "*/*", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT", "loaderType": "DATA" },
{ "key": "FRAME::MARGINHEIGHT", "description": "margin height in pixels",
    "pattern": "[0-9]+", "optional": true },
{ "key": "IFRAME::MARGINHEIGHT", "description": "margin height in pixels",
    "pattern": "[0-9]+", "optional": true },
{ "key": "FRAME::MARGINWIDTH", "description": "margin widths in pixels",
    "pattern": "[0-9]+", "optional": true },
{ "key": "IFRAME::MARGINWIDTH", "description": "margin widths in pixels",
    "pattern": "[0-9]+", "optional": true },
{ "key": "INPUT::MAXLENGTH", "description": "max chars for text fields",
    "pattern": "[0-9]+", "optional": true },
{ "key": "STYLE::MEDIA", "description": "designed for use with these media",
    "type": "MEDIA_QUERY", "optional": true },
{ "key": "LINK::MEDIA", "description": "for rendering on these media",
    "type": "MEDIA_QUERY", "optional": true },
{ "key": "FORM::METHOD", "description": "HTTP method used to submit the form",
    "values": "GET,POST", "default": "GET", "optional": true },
{ "key": "SELECT::MULTIPLE", "description": "default is single selection",
    "values": "multiple", "valueless": true, "optional": true },
{ "key": "BUTTON::NAME",
    "type": "LOCAL_NAME", "optional": true },
{ "key": "TEXTAREA::NAME",
    "type": "LOCAL_NAME", "optional": true },
{ "key": "APPLET::NAME", "description": "allows applets to find each other",
    "type": "GLOBAL_NAME", "optional": true },
{ "key": "SELECT::NAME", "description": "field name",
    "type": "LOCAL_NAME", "optional": true },
{ "key": "FORM::NAME", "description": "name of form for scripting",
    "type": "GLOBAL_NAME", "optional": true },
{ "key": "FRAME::NAME", "description": "name of frame for targetting",
    "type": "GLOBAL_NAME", "optional": true },
{ "key": "IFRAME::NAME", "description": "name of frame for targetting",
    "type": "GLOBAL_NAME", "optional": true },
{ "key": "IMG::NAME", "description": "name of image for scripting",
    "type": "GLOBAL_NAME", "optional": true },
{ "key": "A::NAME", "description": "named link end",
    "type": "GLOBAL_NAME", "optional": true },
{ "key": "INPUT::NAME", "description": "submit as part of form",
    "type": "LOCAL_NAME", "optional": true },
{ "key": "OBJECT::NAME", "description": "submit as part of form",
    "type": "GLOBAL_NAME", "optional": true },
{ "key": "MAP::NAME", "description": "for reference by usemap",
    "type": "GLOBAL_NAME", "optional": false },
{ "key": "PARAM::NAME", "description": "property name",
    "type": "LOCAL_NAME", "optional": false },
{ "key": "META::NAME", "description": "metainformation name",
    "type": "LOCAL_NAME", "optional": true },
{ "key": "AREA::NOHREF", "description": "this region has no action",
    "values": "nohref", "valueless": true, "optional": true },
{ "key": "FRAME::NORESIZE", "description": "allow users to resize frames?",
    "values": "noresize", "valueless": true, "optional": true },
{ "key": "HR::NOSHADE",
    "values": "noshade", "valueless": true, "optional": true },
{ "key": "TD::NOWRAP", "description": "suppress word wrap",
    "values": "nowrap", "valueless": true, "optional": true },
{ "key": "TH::NOWRAP", "description": "suppress word wrap",
    "values": "nowrap", "valueless": true, "optional": true },
{ "key": "APPLET::OBJECT", "description": "serialized applet file",
    "optional": true },
{ "key": "A::ONBLUR", "description": "the element lost the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "AREA::ONBLUR", "description": "the element lost the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "BUTTON::ONBLUR", "description": "the element lost the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "INPUT::ONBLUR", "description": "the element lost the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "LABEL::ONBLUR", "description": "the element lost the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "SELECT::ONBLUR", "description": "the element lost the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "TEXTAREA::ONBLUR", "description": "the element lost the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "INPUT::ONCHANGE", "description": "the element value was changed",
    "type": "SCRIPT", "optional": true },
{ "key": "SELECT::ONCHANGE", "description": "the element value was changed",
    "type": "SCRIPT", "optional": true },
{ "key": "TEXTAREA::ONCHANGE", "description": "the element value was changed",
    "type": "SCRIPT", "optional": true },
{ "key": "*::ONCLICK", "description": "a pointer button was clicked",
    "type": "SCRIPT", "optional": true },
{ "key": "*::ONDBLCLICK", "description": "a pointer button was double clicked",
    "type": "SCRIPT", "optional": true },
{ "key": "A::ONFOCUS", "description": "the element got the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "AREA::ONFOCUS", "description": "the element got the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "BUTTON::ONFOCUS", "description": "the element got the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "INPUT::ONFOCUS", "description": "the element got the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "LABEL::ONFOCUS", "description": "the element got the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "SELECT::ONFOCUS", "description": "the element got the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "TEXTAREA::ONFOCUS", "description": "the element got the focus",
    "type": "SCRIPT", "optional": true },
{ "key": "*::ONKEYDOWN", "description": "a key was pressed down",
    "type": "SCRIPT", "optional": true },
{ "key": "*::ONKEYPRESS", "description": "a key was pressed and released",
    "type": "SCRIPT", "optional": true },
{ "key": "*::ONKEYUP", "description": "a key was released",
    "type": "SCRIPT", "optional": true },
{ "key": "FRAMESET::ONLOAD", "description": "all the frames have been loaded",
    "type": "SCRIPT", "optional": true },
{ "key": "BODY::ONLOAD", "description": "the document has been loaded",
    "type": "SCRIPT", "optional": true },
{ "key": "*::ONMOUSEDOWN", "description": "a pointer button was pressed down",
    "type": "SCRIPT", "optional": true },
{ "key": "*::ONMOUSEMOVE", "description": "a pointer was moved within",
    "type": "SCRIPT", "optional": true },
{ "key": "*::ONMOUSEOUT", "description": "a pointer was moved away",
    "type": "SCRIPT", "optional": true },
{ "key": "*::ONMOUSEOVER", "description": "a pointer was moved onto",
    "type": "SCRIPT", "optional": true },
{ "key": "*::ONMOUSEUP", "description": "a pointer button was released",
    "type": "SCRIPT", "optional": true },
{ "key": "FORM::ONRESET", "description": "the form was reset",
    "type": "SCRIPT", "optional": true },
{ "key": "*::ONSCROLL", "description": "element changed scroll position",
    "type": "SCRIPT", "optional": true },
{ "key": "INPUT::ONSELECT", "description": "some text was selected",
    "type": "SCRIPT", "optional": true },
{ "key": "TEXTAREA::ONSELECT", "description": "some text was selected",
    "type": "SCRIPT", "optional": true },
{ "key": "FORM::ONSUBMIT", "description": "the form was submitted",
    "type": "SCRIPT", "optional": true },
{ "key": "FRAMESET::ONUNLOAD", "description": "all the frames have been removed",
    "type": "SCRIPT", "optional": true },
{ "key": "BODY::ONUNLOAD", "description": "the document has been removed",
    "type": "SCRIPT", "optional": true },
{ "key": "HEAD::PROFILE", "description": "named dictionary of meta info",
    "mimeTypes": "application/*", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT", "loaderType": "DATA" },
{ "key": "ISINDEX::PROMPT", "description": "prompt message",
    "optional": true },
{ "key": "TEXTAREA::READONLY",
    "values": "readonly", "valueless": true, "optional": true },
{ "key": "INPUT::READONLY", "description": "for text and passwd",
    "values": "readonly", "valueless": true, "optional": true },
{ "key": "A::REL", "description": "forward link types",
    "optional": true },
{ "key": "LINK::REL", "description": "forward link types",
    "optional": true },
{ "key": "A::REV", "description": "reverse link types",
    "optional": true },
{ "key": "LINK::REV", "description": "reverse link types",
    "optional": true },
{ "key": "FRAMESET::ROWS", "description": "list of lengths, default: 100% (1 row)",
    "optional": true },
{ "key": "TEXTAREA::ROWS",
    "pattern": "[0-9]+", "optional": true },
{ "key": "TD::ROWSPAN", "description": "number of rows spanned by cell",
    "pattern": "[0-9]+", "default": "1", "optional": true },
{ "key": "TH::ROWSPAN", "description": "number of rows spanned by cell",
    "pattern": "[0-9]+", "default": "1", "optional": true },
{ "key": "TABLE::RULES", "description": "rulings between rows and cols",
    "optional": true },
{ "key": "META::SCHEME", "description": "select form of content",
    "optional": true },
{ "key": "TD::SCOPE", "description": "scope covered by header cells",
    "optional": true },
{ "key": "TH::SCOPE", "description": "scope covered by header cells",
    "optional": true },
{ "key": "FRAME::SCROLLING", "description": "scrollbar or none",
    "values": "yes,no,auto", "default": "auto", "optional": true },
{ "key": "IFRAME::SCROLLING", "description": "scrollbar or none",
    "values": "yes,no,auto", "default": "auto", "optional": true },
{ "key": "OPTION::SELECTED",
    "values": "selected", "valueless": true, "optional": true },
{ "key": "AREA::SHAPE", "description": "controls interpretation of coords",
    "default": "rect", "optional": true },
{ "key": "A::SHAPE", "description": "for use with client-side image maps",
    "default": "rect", "optional": true },
{ "key": "HR::SIZE",
    "pattern": "[0-9]+", "optional": true },
{ "key": "FONT::SIZE", "description": "[+|-]nn e.g. size=\"+1\", size=\"4\"",
    "optional": true },
{ "key": "INPUT::SIZE", "description": "specific to each type of field",
    "optional": true },
{ "key": "BASEFONT::SIZE", "description": "base font size for FONT elements",
    "optional": false },
{ "key": "SELECT::SIZE", "description": "rows visible",
    "pattern": "[0-9]+", "optional": true },
{ "key": "COL::SPAN", "description": "COL attributes affect N columns",
    "pattern": "[0-9]+", "default": "1", "optional": true },
{ "key": "COLGROUP::SPAN", "description": "default number of columns in group",
    "pattern": "[0-9]+", "default": "1", "optional": true },
{ "key": "SCRIPT::SRC", "description": "URI for an external script",
    "mimeTypes": "text/javascript", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT",
    "loaderType": "UNSANDBOXED" },
{ "key": "INPUT::SRC", "description": "for fields with images",
    "mimeTypes": "image/*", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT",
    "loaderType": "SANDBOXED" },
{ "key": "FRAME::SRC", "description": "source of frame content",
    "mimeTypes": "text/html", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT",
    "loaderType": "UNSANDBOXED" },
{ "key": "IFRAME::SRC", "description": "source of frame content",
    "mimeTypes": "text/html", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT",
    "loaderType": "UNSANDBOXED" },
{ "key": "IMG::SRC", "description": "URI of image to embed",
    "mimeTypes": "image/*", "optional": true,
    "type": "URI", "uriEffect": "SAME_DOCUMENT",
    "loaderType": "SANDBOXED" },
{ "key": "OBJECT::STANDBY", "description": "message to show while loading",
    "optional": true },
{ "key": "OL::START", "description": "starting sequence number",
    "pattern": "[0-9]+", "optional": true },
{ "key": "*::STYLE", "description": "associated style info",
    "type": "STYLE", "optional": true },
{ "key": "TABLE::SUMMARY",
    "description": "purpose/structure for speech output",
    "optional": true },
{ "key": "A::TABINDEX", "description": "position in tabbing order",
    "pattern": "[0-9]+", "optional": true },
{ "key": "AREA::TABINDEX", "description": "position in tabbing order",
    "pattern": "[0-9]+", "optional": true },
{ "key": "BUTTON::TABINDEX", "description": "position in tabbing order",
    "pattern": "[0-9]+", "optional": true },
{ "key": "INPUT::TABINDEX", "description": "position in tabbing order",
    "pattern": "[0-9]+", "optional": true },
{ "key": "OBJECT::TABINDEX", "description": "position in tabbing order",
    "pattern": "[0-9]+", "optional": true },
{ "key": "SELECT::TABINDEX", "description": "position in tabbing order",
    "pattern": "[0-9]+", "optional": true },
{ "key": "TEXTAREA::TABINDEX", "description": "position in tabbing order",
    "pattern": "[0-9]+", "optional": true },
{ "key": "A::TARGET", "description": "render in this frame",
    "type": "FRAME_TARGET", "default": "_self", "optional": true },
{ "key": "AREA::TARGET", "description": "render in this frame",
    "type": "FRAME_TARGET", "default": "_self", "optional": true },
{ "key": "BASE::TARGET", "description": "render in this frame",
    "type": "FRAME_TARGET", "default": "_self", "optional": true },
{ "key": "FORM::TARGET", "description": "render in this frame",
    "type": "FRAME_TARGET", "default": "_self", "optional": true },
{ "key": "LINK::TARGET", "description": "render in this frame",
    "type": "FRAME_TARGET", "default": "_self", "optional": true },
{ "key": "BODY::TEXT", "description": "document text color",
    "pattern": "\\w+|#[0-9A-Fa-f]{6}", "optional": true },
{ "key": "*::TITLE", "description": "advisory title",
    "optional": true },
{ "key": "A::TYPE", "description": "advisory content type",
    "optional": true },
{ "key": "LINK::TYPE", "description": "advisory content type",
    "optional": true },
{ "key": "OBJECT::TYPE", "description": "content type for data",
    "optional": true },
{ "key": "PARAM::TYPE", "description": "content type for value when valuetype=ref",
    "optional": true },
{ "key": "SCRIPT::TYPE", "description": "content type of script language",
    "optional": false, "default": "text/javascript" },
{ "key": "STYLE::TYPE", "description": "content type of style language",
    "optional": false, "default": "text/css" },
{ "key": "INPUT::TYPE", "description": "Type of form control",
    "values": "hidden,text,search,tel,url,email,password,datetime,date,month,week,time,datetime-local,number,range,color,checkbox,radio,file,submit,image,reset,button",
    "comment": "Values include HTML5 features",
    "default": "TEXT", "optional": true },
{ "key": "LI::TYPE", "description": "list item style",
    "optional": true },
{ "key": "OL::TYPE", "description": "numbering style",
    "optional": true },
{ "key": "UL::TYPE", "description": "bullet style",
    "optional": true },
{ "key": "BUTTON::TYPE", "description": "for use as form button",
    "values": "button,submit,reset", "default": "submit", "optional": true },
{ "key": "IMG::USEMAP", "description": "use client-side image map",
    "pattern": "#.+", "optional": true, "type": "URI_FRAGMENT" },
{ "key": "INPUT::USEMAP", "description": "use client-side image map",
    "pattern": "#.+", "optional": true, "type": "URI_FRAGMENT" },
{ "key": "OBJECT::USEMAP", "description": "use client-side image map",
    "pattern": "#.+", "optional": true, "type": "URI_FRAGMENT" },
{ "key": "COL::VALIGN", "description": "vertical alignment in cells",
    "values": "top,middle,bottom,baseline", "optional": true },
{ "key": "COLGROUP::VALIGN", "description": "vertical alignment in cells",
    "values": "top,middle,bottom,baseline", "optional": true },
{ "key": "TBODY::VALIGN", "description": "vertical alignment in cells",
    "values": "top,middle,bottom,baseline", "optional": true },
{ "key": "TD::VALIGN", "description": "vertical alignment in cells",
    "values": "top,middle,bottom,baseline", "optional": true },
{ "key": "TFOOT::VALIGN", "description": "vertical alignment in cells",
    "values": "top,middle,bottom,baseline", "optional": true },
{ "key": "TH::VALIGN", "description": "vertical alignment in cells",
    "values": "top,middle,bottom,baseline", "optional": true },
{ "key": "THEAD::VALIGN", "description": "vertical alignment in cells",
    "values": "top,middle,bottom,baseline", "optional": true },
{ "key": "TR::VALIGN", "description": "vertical alignment in cells",
    "values": "top,middle,bottom,baseline", "optional": true },
{ "key": "INPUT::VALUE", "description": "Specify for radio buttons and checkboxes",
    "optional": true },
{ "key": "OPTION::VALUE", "description": "defaults to element content",
    "optional": true },
{ "key": "PARAM::VALUE", "description": "property value",
    "optional": true },
{ "key": "BUTTON::VALUE", "description": "sent to server when submitted",
    "optional": true },
{ "key": "LI::VALUE", "description": "reset sequence number",
    "pattern": "[0-9]+", "optional": true },
{ "key": "PARAM::VALUETYPE", "description": "How to interpret value",
    "values": "DATA,REF,OBJECT", "default": "DATA", "optional": true },
{ "key": "HTML::VERSION", "description": "Constant",
    "optional": true },
{ "key": "BODY::VLINK", "description": "color of visited links",
    "pattern": "\\w+|#[0-9A-Fa-f]{6}", "optional": true },
{ "key": "APPLET::VSPACE", "description": "vertical gutter",
    "pattern": "[0-9]+", "optional": true },
{ "key": "IMG::VSPACE", "description": "vertical gutter",
    "pattern": "[0-9]+", "optional": true },
{ "key": "OBJECT::VSPACE", "description": "vertical gutter",
    "pattern": "[0-9]+", "optional": true },
{ "key": "HR::WIDTH",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "IFRAME::WIDTH", "description": "frame width",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "IMG::WIDTH", "description": "override width",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "OBJECT::WIDTH", "description": "override width",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "TABLE::WIDTH", "description": "table width",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "TD::WIDTH", "description": "width for cell",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "TH::WIDTH", "description": "width for cell",
    "pattern": "[0-9]+%?", "optional": true },
{ "key": "APPLET::WIDTH", "description": "initial width",
    "pattern": "[0-9]+%?", "optional": false },
{ "key": "COL::WIDTH", "description": "column width specification",
    "optional": true },
{ "key": "COLGROUP::WIDTH", "description": "default width for enclosed COLs",
    "optional": true },
{ "key": "PRE::WIDTH",
    "pattern": "[0-9]+", "optional": true }
]

}
html4 .LOADERTYPES = {}

// The Turkish i seems to be a non-issue, but abort in case it is.
if ('I'.toLowerCase() !== 'i') { throw 'I/i problem'; }

/**
 * \@namespace
 */
var html = (function(html4) {

    // For closure compiler
    var parseCssDeclarations, sanitizeCssProperty, cssSchema;
    if ('undefined' !== typeof window) {
        parseCssDeclarations = window['parseCssDeclarations'];
        sanitizeCssProperty = window['sanitizeCssProperty'];
        cssSchema = window['cssSchema'];
    }

    // The keys of this object must be 'quoted' or JSCompiler will mangle them!
    // This is a partial list -- lookupEntity() uses the host browser's parser
    // (when available) to implement full entity lookup.
    // Note that entities are in general case-sensitive; the uppercase ones are
    // explicitly defined by HTML5 (presumably as compatibility).
    var ENTITIES = {
        'lt': '<',
        'LT': '<',
        'gt': '>',
        'GT': '>',
        'amp': '&',
        'AMP': '&',
        'quot': '"',
        'apos': '\'',
        'nbsp': '\240'
    };

    // Patterns for types of entity/character reference names.
    var decimalEscapeRe = /^#(\d+)$/;
    var hexEscapeRe = /^#x([0-9A-Fa-f]+)$/;
    // contains every entity per http://www.w3.org/TR/2011/WD-html5-20110113/named-character-references.html
    var safeEntityNameRe = /^[A-Za-z][A-za-z0-9]+$/;
    // Used as a hook to invoke the browser's entity parsing. <textarea> is used
    // because its content is parsed for entities but not tags.
    // TODO(kpreid): This retrieval is a kludge and leads to silent loss of
    // functionality if the document isn't available.
    var entityLookupElement =
        ('undefined' !== typeof window && window['document'])
            ? window['document'].createElement('textarea') : null;
    /**
     * Decodes an HTML entity.
     *
     * {\@updoc
     * $ lookupEntity('lt')
     * # '<'
     * $ lookupEntity('GT')
     * # '>'
     * $ lookupEntity('amp')
     * # '&'
     * $ lookupEntity('nbsp')
     * # '\xA0'
     * $ lookupEntity('apos')
     * # "'"
     * $ lookupEntity('quot')
     * # '"'
     * $ lookupEntity('#xa')
     * # '\n'
     * $ lookupEntity('#10')
     * # '\n'
     * $ lookupEntity('#x0a')
     * # '\n'
     * $ lookupEntity('#010')
     * # '\n'
     * $ lookupEntity('#x00A')
     * # '\n'
     * $ lookupEntity('Pi')      // Known failure
     * # '\u03A0'
     * $ lookupEntity('pi')      // Known failure
     * # '\u03C0'
     * }
     *
     * @param {string} name the content between the '&' and the ';'.
     * @return {string} a single unicode code-point as a string.
     */
    function lookupEntity(name) {
        // TODO: entity lookup as specified by HTML5 actually depends on the
        // presence of the ";".
        if (ENTITIES.hasOwnProperty(name)) { return ENTITIES[name]; }
        var m = name.match(decimalEscapeRe);
        if (m) {
            return String.fromCharCode(parseInt(m[1], 10));
        } else if (!!(m = name.match(hexEscapeRe))) {
            return String.fromCharCode(parseInt(m[1], 16));
        } else if (entityLookupElement && safeEntityNameRe.test(name)) {
            entityLookupElement.innerHTML = '&' + name + ';';
            var text = entityLookupElement.textContent;
            ENTITIES[name] = text;
            return text;
        } else {
            return '&' + name + ';';
        }
    }

    function decodeOneEntity(_, name) {
        return lookupEntity(name);
    }

    var nulRe = /\0/g;
    function stripNULs(s) {
        return s.replace(nulRe, '');
    }

    var ENTITY_RE_1 = /&(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/g;
    var ENTITY_RE_2 = /^(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/;
    /**
     * The plain text of a chunk of HTML CDATA which possibly containing.
     *
     * {\@updoc
     * $ unescapeEntities('')
     * # ''
     * $ unescapeEntities('hello World!')
     * # 'hello World!'
     * $ unescapeEntities('1 &lt; 2 &amp;&AMP; 4 &gt; 3&#10;')
     * # '1 < 2 && 4 > 3\n'
     * $ unescapeEntities('&lt;&lt <- unfinished entity&gt;')
     * # '<&lt <- unfinished entity>'
     * $ unescapeEntities('/foo?bar=baz&copy=true')  // & often unescaped in URLS
     * # '/foo?bar=baz&copy=true'
     * $ unescapeEntities('pi=&pi;&#x3c0;, Pi=&Pi;\u03A0') // FIXME: known failure
     * # 'pi=\u03C0\u03c0, Pi=\u03A0\u03A0'
     * }
     *
     * @param {string} s a chunk of HTML CDATA.  It must not start or end inside
     *     an HTML entity.
     */
    function unescapeEntities(s) {
        return s.replace(ENTITY_RE_1, decodeOneEntity);
    }

    var ampRe = /&/g;
    var looseAmpRe = /&([^a-z#]|#(?:[^0-9x]|x(?:[^0-9a-f]|$)|$)|$)/gi;
    var ltRe = /[<]/g;
    var gtRe = />/g;
    var quotRe = /\"/g;

    /**
     * Escapes HTML special characters in attribute values.
     *
     * {\@updoc
     * $ escapeAttrib('')
     * # ''
     * $ escapeAttrib('"<<&==&>>"')  // Do not just escape the first occurrence.
     * # '&#34;&lt;&lt;&amp;&#61;&#61;&amp;&gt;&gt;&#34;'
     * $ escapeAttrib('Hello <World>!')
     * # 'Hello &lt;World&gt;!'
     * }
     */
    function escapeAttrib(s) {
        return ('' + s).replace(ampRe, '&amp;').replace(ltRe, '&lt;')
            .replace(gtRe, '&gt;').replace(quotRe, '&#34;');
    }

    /**
     * Escape entities in RCDATA that can be escaped without changing the meaning.
     * {\@updoc
     * $ normalizeRCData('1 < 2 &&amp; 3 > 4 &amp;& 5 &lt; 7&8')
     * # '1 &lt; 2 &amp;&amp; 3 &gt; 4 &amp;&amp; 5 &lt; 7&amp;8'
     * }
     */
    function normalizeRCData(rcdata) {
        return rcdata
            .replace(looseAmpRe, '&amp;$1')
            .replace(ltRe, '&lt;')
            .replace(gtRe, '&gt;');
    }

    // TODO(felix8a): validate sanitizer regexs against the HTML5 grammar at
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html

    // We initially split input so that potentially meaningful characters
    // like '<' and '>' are separate tokens, using a fast dumb process that
    // ignores quoting.  Then we walk that token stream, and when we see a
    // '<' that's the start of a tag, we use ATTR_RE to extract tag
    // attributes from the next token.  That token will never have a '>'
    // character.  However, it might have an unbalanced quote character, and
    // when we see that, we combine additional tokens to balance the quote.

    var ATTR_RE = new RegExp(
        '^\\s*' +
            '([-.:\\w]+)' +             // 1 = Attribute name
            '(?:' + (
            '\\s*(=)\\s*' +           // 2 = Is there a value?
                '(' + (                   // 3 = Attribute value
                // TODO(felix8a): maybe use backref to match quotes
                '(\")[^\"]*(\"|$)' +    // 4, 5 = Double-quoted string
                    '|' +
                    '(\')[^\']*(\'|$)' +    // 6, 7 = Single-quoted string
                    '|' +
                    // Positive lookahead to prevent interpretation of
                    // <foo a= b=c> as <foo a='b=c'>
                    // TODO(felix8a): might be able to drop this case
                    '(?=[a-z][-\\w]*\\s*=)' +
                    '|' +
                    // Unquoted value that isn't an attribute name
                    // (since we didn't match the positive lookahead above)
                    '[^\"\'\\s]*' ) +
                ')' ) +
            ')?',
        'i');

    // false on IE<=8, true on most other browsers
    var splitWillCapture = ('a,b'.split(/(,)/).length === 3);

    // bitmask for tags with special parsing, like <script> and <textarea>
    var EFLAGS_TEXT = html4.eflags['CDATA'] | html4.eflags['RCDATA'];

    /**
     * Given a SAX-like event handler, produce a function that feeds those
     * events and a parameter to the event handler.
     *
     * The event handler has the form:{@code
     * {
   *   // Name is an upper-case HTML tag name.  Attribs is an array of
   *   // alternating upper-case attribute names, and attribute values.  The
   *   // attribs array is reused by the parser.  Param is the value passed to
   *   // the saxParser.
   *   startTag: function (name, attribs, param) { ... },
   *   endTag:   function (name, param) { ... },
   *   pcdata:   function (text, param) { ... },
   *   rcdata:   function (text, param) { ... },
   *   cdata:    function (text, param) { ... },
   *   startDoc: function (param) { ... },
   *   endDoc:   function (param) { ... }
   * }}
     *
     * @param {Object} handler a record containing event handlers.
     * @return {function(string, Object)} A function that takes a chunk of HTML
     *     and a parameter.  The parameter is passed on to the handler methods.
     */
    function makeSaxParser(handler) {
        // Accept quoted or unquoted keys (Closure compat)
        var hcopy = {
            cdata: handler.cdata || handler['cdata'],
            comment: handler.comment || handler['comment'],
            endDoc: handler.endDoc || handler['endDoc'],
            endTag: handler.endTag || handler['endTag'],
            pcdata: handler.pcdata || handler['pcdata'],
            rcdata: handler.rcdata || handler['rcdata'],
            startDoc: handler.startDoc || handler['startDoc'],
            startTag: handler.startTag || handler['startTag']
        };
        return function(htmlText, param) {
            return parse(htmlText, hcopy, param);
        };
    }

    // Parsing strategy is to split input into parts that might be lexically
    // meaningful (every ">" becomes a separate part), and then recombine
    // parts if we discover they're in a different context.

    // TODO(felix8a): Significant performance regressions from -legacy,
    // tested on
    //    Chrome 18.0
    //    Firefox 11.0
    //    IE 6, 7, 8, 9
    //    Opera 11.61
    //    Safari 5.1.3
    // Many of these are unusual patterns that are linearly slower and still
    // pretty fast (eg 1ms to 5ms), so not necessarily worth fixing.

    // TODO(felix8a): "<script> && && && ... <\/script>" is slower on all
    // browsers.  The hotspot is htmlSplit.

    // TODO(felix8a): "<p title='>>>>...'><\/p>" is slower on all browsers.
    // This is partly htmlSplit, but the hotspot is parseTagAndAttrs.

    // TODO(felix8a): "<a><\/a><a><\/a>..." is slower on IE9.
    // "<a>1<\/a><a>1<\/a>..." is faster, "<a><\/a>2<a><\/a>2..." is faster.

    // TODO(felix8a): "<p<p<p..." is slower on IE[6-8]

    var continuationMarker = {};
    function parse(htmlText, handler, param) {
        var m, p, tagName;
        var parts = htmlSplit(htmlText);
        var state = {
            noMoreGT: false,
            noMoreEndComments: false
        };
        parseCPS(handler, parts, 0, state, param);
    }

    function continuationMaker(h, parts, initial, state, param) {
        return function () {
            parseCPS(h, parts, initial, state, param);
        };
    }

    function parseCPS(h, parts, initial, state, param) {
        try {
            if (h.startDoc && initial == 0) { h.startDoc(param); }
            var m, p, tagName;
            for (var pos = initial, end = parts.length; pos < end;) {
                var current = parts[pos++];
                var next = parts[pos];
                switch (current) {
                    case '&':
                        if (ENTITY_RE_2.test(next)) {
                            if (h.pcdata) {
                                h.pcdata('&' + next, param, continuationMarker,
                                    continuationMaker(h, parts, pos, state, param));
                            }
                            pos++;
                        } else {
                            if (h.pcdata) { h.pcdata("&amp;", param, continuationMarker,
                                continuationMaker(h, parts, pos, state, param));
                            }
                        }
                        break;
                    case '<\/':
                        if ((m = /^([-\w:]+)[^\'\"]*/.exec(next))) {
                            if (m[0].length === next.length && parts[pos + 1] === '>') {
                                // fast case, no attribute parsing needed
                                pos += 2;
                                tagName = m[1].toLowerCase();
                                if (h.endTag) {
                                    h.endTag(tagName, param, continuationMarker,
                                        continuationMaker(h, parts, pos, state, param));
                                }
                            } else {
                                // slow case, need to parse attributes
                                // TODO(felix8a): do we really care about misparsing this?
                                pos = parseEndTag(
                                    parts, pos, h, param, continuationMarker, state);
                            }
                        } else {
                            if (h.pcdata) {
                                h.pcdata('&lt;/', param, continuationMarker,
                                    continuationMaker(h, parts, pos, state, param));
                            }
                        }
                        break;
                    case '<':
                        if (m = /^([-\w:]+)\s*\/?/.exec(next)) {
                            if (m[0].length === next.length && parts[pos + 1] === '>') {
                                // fast case, no attribute parsing needed
                                pos += 2;
                                tagName = m[1].toLowerCase();
                                if (h.startTag) {
                                    h.startTag(tagName, [], param, continuationMarker,
                                        continuationMaker(h, parts, pos, state, param));
                                }
                                // tags like <script> and <textarea> have special parsing
                                var eflags = html4.ELEMENTS[tagName];
                                if (eflags & EFLAGS_TEXT) {
                                    var tag = { name: tagName, next: pos, eflags: eflags };
                                    pos = parseText(
                                        parts, tag, h, param, continuationMarker, state);
                                }
                            } else {
                                // slow case, need to parse attributes
                                pos = parseStartTag(
                                    parts, pos, h, param, continuationMarker, state);
                            }
                        } else {
                            if (h.pcdata) {
                                h.pcdata('&lt;', param, continuationMarker,
                                    continuationMaker(h, parts, pos, state, param));
                            }
                        }
                        break;
                    case '<\!--':
                        // The pathological case is n copies of '<\!--' without '-->', and
                        // repeated failure to find '-->' is quadratic.  We avoid that by
                        // remembering when search for '-->' fails.
                        if (!state.noMoreEndComments) {
                            // A comment <\!--x--> is split into three tokens:
                            //   '<\!--', 'x--', '>'
                            // We want to find the next '>' token that has a preceding '--'.
                            // pos is at the 'x--'.
                            for (p = pos + 1; p < end; p++) {
                                if (parts[p] === '>' && /--$/.test(parts[p - 1])) { break; }
                            }
                            if (p < end) {
                                if (h.comment) {
                                    var comment = parts.slice(pos, p).join('');
                                    h.comment(
                                        comment.substr(0, comment.length - 2), param,
                                        continuationMarker,
                                        continuationMaker(h, parts, p + 1, state, param));
                                }
                                pos = p + 1;
                            } else {
                                state.noMoreEndComments = true;
                            }
                        }
                        if (state.noMoreEndComments) {
                            if (h.pcdata) {
                                h.pcdata('&lt;!--', param, continuationMarker,
                                    continuationMaker(h, parts, pos, state, param));
                            }
                        }
                        break;
                    case '<\!':
                        if (!/^\w/.test(next)) {
                            if (h.pcdata) {
                                h.pcdata('&lt;!', param, continuationMarker,
                                    continuationMaker(h, parts, pos, state, param));
                            }
                        } else {
                            // similar to noMoreEndComment logic
                            if (!state.noMoreGT) {
                                for (p = pos + 1; p < end; p++) {
                                    if (parts[p] === '>') { break; }
                                }
                                if (p < end) {
                                    pos = p + 1;
                                } else {
                                    state.noMoreGT = true;
                                }
                            }
                            if (state.noMoreGT) {
                                if (h.pcdata) {
                                    h.pcdata('&lt;!', param, continuationMarker,
                                        continuationMaker(h, parts, pos, state, param));
                                }
                            }
                        }
                        break;
                    case '<?':
                        // similar to noMoreEndComment logic
                        if (!state.noMoreGT) {
                            for (p = pos + 1; p < end; p++) {
                                if (parts[p] === '>') { break; }
                            }
                            if (p < end) {
                                pos = p + 1;
                            } else {
                                state.noMoreGT = true;
                            }
                        }
                        if (state.noMoreGT) {
                            if (h.pcdata) {
                                h.pcdata('&lt;?', param, continuationMarker,
                                    continuationMaker(h, parts, pos, state, param));
                            }
                        }
                        break;
                    case '>':
                        if (h.pcdata) {
                            h.pcdata("&gt;", param, continuationMarker,
                                continuationMaker(h, parts, pos, state, param));
                        }
                        break;
                    case '':
                        break;
                    default:
                        if (h.pcdata) {
                            h.pcdata(current, param, continuationMarker,
                                continuationMaker(h, parts, pos, state, param));
                        }
                        break;
                }
            }
            if (h.endDoc) { h.endDoc(param); }
        } catch (e) {
            if (e !== continuationMarker) { throw e; }
        }
    }

    // Split str into parts for the html parser.
    function htmlSplit(str) {
        // can't hoist this out of the function because of the re.exec loop.
        var re = /(<\/|<\!--|<[!?]|[&<>])/g;
        str += '';
        if (splitWillCapture) {
            return str.split(re);
        } else {
            var parts = [];
            var lastPos = 0;
            var m;
            while ((m = re.exec(str)) !== null) {
                parts.push(str.substring(lastPos, m.index));
                parts.push(m[0]);
                lastPos = m.index + m[0].length;
            }
            parts.push(str.substring(lastPos));
            return parts;
        }
    }

    function parseEndTag(parts, pos, h, param, continuationMarker, state) {
        var tag = parseTagAndAttrs(parts, pos);
        // drop unclosed tags
        if (!tag) { return parts.length; }
        if (h.endTag) {
            h.endTag(tag.name, param, continuationMarker,
                continuationMaker(h, parts, pos, state, param));
        }
        return tag.next;
    }

    function parseStartTag(parts, pos, h, param, continuationMarker, state) {
        var tag = parseTagAndAttrs(parts, pos);
        // drop unclosed tags
        if (!tag) { return parts.length; }
        if (h.startTag) {
            h.startTag(tag.name, tag.attrs, param, continuationMarker,
                continuationMaker(h, parts, tag.next, state, param));
        }
        // tags like <script> and <textarea> have special parsing
        if (tag.eflags & EFLAGS_TEXT) {
            return parseText(parts, tag, h, param, continuationMarker, state);
        } else {
            return tag.next;
        }
    }

    var endTagRe = {};

    // Tags like <script> and <textarea> are flagged as CDATA or RCDATA,
    // which means everything is text until we see the correct closing tag.
    function parseText(parts, tag, h, param, continuationMarker, state) {
        var end = parts.length;
        if (!endTagRe.hasOwnProperty(tag.name)) {
            endTagRe[tag.name] = new RegExp('^' + tag.name + '(?:[\\s\\/]|$)', 'i');
        }
        var re = endTagRe[tag.name];
        var first = tag.next;
        var p = tag.next + 1;
        for (; p < end; p++) {
            if (parts[p - 1] === '<\/' && re.test(parts[p])) { break; }
        }
        if (p < end) { p -= 1; }
        var buf = parts.slice(first, p).join('');
        if (tag.eflags & html4.eflags['CDATA']) {
            if (h.cdata) {
                h.cdata(buf, param, continuationMarker,
                    continuationMaker(h, parts, p, state, param));
            }
        } else if (tag.eflags & html4.eflags['RCDATA']) {
            if (h.rcdata) {
                h.rcdata(normalizeRCData(buf), param, continuationMarker,
                    continuationMaker(h, parts, p, state, param));
            }
        } else {
            throw new Error('bug');
        }
        return p;
    }

    // at this point, parts[pos-1] is either "<" or "<\/".
    function parseTagAndAttrs(parts, pos) {
        var m = /^([-\w:]+)/.exec(parts[pos]);
        var tag = {};
        tag.name = m[1].toLowerCase();
        tag.eflags = html4.ELEMENTS[tag.name];
        var buf = parts[pos].substr(m[0].length);
        // Find the next '>'.  We optimistically assume this '>' is not in a
        // quoted context, and further down we fix things up if it turns out to
        // be quoted.
        var p = pos + 1;
        var end = parts.length;
        for (; p < end; p++) {
            if (parts[p] === '>') { break; }
            buf += parts[p];
        }
        if (end <= p) { return void 0; }
        var attrs = [];
        while (buf !== '') {
            m = ATTR_RE.exec(buf);
            if (!m) {
                // No attribute found: skip garbage
                buf = buf.replace(/^[\s\S][^a-z\s]*/, '');

            } else if ((m[4] && !m[5]) || (m[6] && !m[7])) {
                // Unterminated quote: slurp to the next unquoted '>'
                var quote = m[4] || m[6];
                var sawQuote = false;
                var abuf = [buf, parts[p++]];
                for (; p < end; p++) {
                    if (sawQuote) {
                        if (parts[p] === '>') { break; }
                    } else if (0 <= parts[p].indexOf(quote)) {
                        sawQuote = true;
                    }
                    abuf.push(parts[p]);
                }
                // Slurp failed: lose the garbage
                if (end <= p) { break; }
                // Otherwise retry attribute parsing
                buf = abuf.join('');
                continue;

            } else {
                // We have an attribute
                var aName = m[1].toLowerCase();
                var aValue = m[2] ? decodeValue(m[3]) : '';
                attrs.push(aName, aValue);
                buf = buf.substr(m[0].length);
            }
        }
        tag.attrs = attrs;
        tag.next = p + 1;
        return tag;
    }

    function decodeValue(v) {
        var q = v.charCodeAt(0);
        if (q === 0x22 || q === 0x27) { // " or '
            v = v.substr(1, v.length - 2);
        }
        return unescapeEntities(stripNULs(v));
    }

    /**
     * Returns a function that strips unsafe tags and attributes from html.
     * @param {function(string, Array.<string>): ?Array.<string>} tagPolicy
     *     A function that takes (tagName, attribs[]), where tagName is a key in
     *     html4.ELEMENTS and attribs is an array of alternating attribute names
     *     and values.  It should return a record (as follows), or null to delete
     *     the element.  It's okay for tagPolicy to modify the attribs array,
     *     but the same array is reused, so it should not be held between calls.
     *     Record keys:
     *        attribs: (required) Sanitized attributes array.
     *        tagName: Replacement tag name.
     * @return {function(string, Array)} A function that sanitizes a string of
     *     HTML and appends result strings to the second argument, an array.
     */
    function makeHtmlSanitizer(tagPolicy) {
        var stack;
        var ignoring;
        var emit = function (text, out) {
            if (!ignoring) { out.push(text); }
        };
        return makeSaxParser({
            'startDoc': function(_) {
                stack = [];
                ignoring = false;
            },
            'startTag': function(tagNameOrig, attribs, out) {
                if (ignoring) { return; }
                if (!html4.ELEMENTS.hasOwnProperty(tagNameOrig)) { return; }
                var eflagsOrig = html4.ELEMENTS[tagNameOrig];
                if (eflagsOrig & html4.eflags['FOLDABLE']) {
                    return;
                }

                var decision = tagPolicy(tagNameOrig, attribs);
                if (!decision) {
                    ignoring = !(eflagsOrig & html4.eflags['EMPTY']);
                    return;
                } else if (typeof decision !== 'object') {
                    throw new Error('tagPolicy did not return object (old API?)');
                }
                if ('attribs' in decision) {
                    attribs = decision['attribs'];
                } else {
                    throw new Error('tagPolicy gave no attribs');
                }
                var eflagsRep;
                var tagNameRep;
                if ('tagName' in decision) {
                    tagNameRep = decision['tagName'];
                    eflagsRep = html4.ELEMENTS[tagNameRep];
                } else {
                    tagNameRep = tagNameOrig;
                    eflagsRep = eflagsOrig;
                }
                // TODO(mikesamuel): relying on tagPolicy not to insert unsafe
                // attribute names.

                // If this is an optional-end-tag element and either this element or its
                // previous like sibling was rewritten, then insert a close tag to
                // preserve structure.
                if (eflagsOrig & html4.eflags['OPTIONAL_ENDTAG']) {
                    var onStack = stack[stack.length - 1];
                    if (onStack && onStack.orig === tagNameOrig &&
                        (onStack.rep !== tagNameRep || tagNameOrig !== tagNameRep)) {
                        out.push('<\/', onStack.rep, '>');
                    }
                }

                if (!(eflagsOrig & html4.eflags['EMPTY'])) {
                    stack.push({orig: tagNameOrig, rep: tagNameRep});
                }

                out.push('<', tagNameRep);
                for (var i = 0, n = attribs.length; i < n; i += 2) {
                    var attribName = attribs[i],
                        value = attribs[i + 1];
                    if (value !== null && value !== void 0) {
                        out.push(' ', attribName, '="', escapeAttrib(value), '"');
                    }
                }
                out.push('>');

                if ((eflagsOrig & html4.eflags['EMPTY'])
                    && !(eflagsRep & html4.eflags['EMPTY'])) {
                    // replacement is non-empty, synthesize end tag
                    out.push('<\/', tagNameRep, '>');
                }
            },
            'endTag': function(tagName, out) {
                if (ignoring) {
                    ignoring = false;
                    return;
                }
                if (!html4.ELEMENTS.hasOwnProperty(tagName)) { return; }
                var eflags = html4.ELEMENTS[tagName];
                if (!(eflags & (html4.eflags['EMPTY'] | html4.eflags['FOLDABLE']))) {
                    var index;
                    if (eflags & html4.eflags['OPTIONAL_ENDTAG']) {
                        for (index = stack.length; --index >= 0;) {
                            var stackElOrigTag = stack[index].orig;
                            if (stackElOrigTag === tagName) { break; }
                            if (!(html4.ELEMENTS[stackElOrigTag] &
                                html4.eflags['OPTIONAL_ENDTAG'])) {
                                // Don't pop non optional end tags looking for a match.
                                return;
                            }
                        }
                    } else {
                        for (index = stack.length; --index >= 0;) {
                            if (stack[index].orig === tagName) { break; }
                        }
                    }
                    if (index < 0) { return; }  // Not opened.
                    for (var i = stack.length; --i > index;) {
                        var stackElRepTag = stack[i].rep;
                        if (!(html4.ELEMENTS[stackElRepTag] &
                            html4.eflags['OPTIONAL_ENDTAG'])) {
                            out.push('<\/', stackElRepTag, '>');
                        }
                    }
                    if (index < stack.length) {
                        tagName = stack[index].rep;
                    }
                    stack.length = index;
                    out.push('<\/', tagName, '>');
                }
            },
            'pcdata': emit,
            'rcdata': emit,
            'cdata': emit,
            'endDoc': function(out) {
                for (; stack.length; stack.length--) {
                    out.push('<\/', stack[stack.length - 1].rep, '>');
                }
            }
        });
    }

    var ALLOWED_URI_SCHEMES = /^(?:https?|mailto)$/i;

    function safeUri(uri, effect, ltype, hints, naiveUriRewriter) {
        if (!naiveUriRewriter) { return null; }
        try {
            var parsed = URI.parse('' + uri);
            if (parsed) {
                if (!parsed.hasScheme() ||
                    ALLOWED_URI_SCHEMES.test(parsed.getScheme())) {
                    var safe = naiveUriRewriter(parsed, effect, ltype, hints);
                    return safe ? safe.toString() : null;
                }
            }
        } catch (e) {
            return null;
        }
        return null;
    }

    function log(logger, tagName, attribName, oldValue, newValue) {
        if (!attribName) {
            logger(tagName + " removed", {
                change: "removed",
                tagName: tagName
            });
        }
        if (oldValue !== newValue) {
            var changed = "changed";
            if (oldValue && !newValue) {
                changed = "removed";
            } else if (!oldValue && newValue)  {
                changed = "added";
            }
            logger(tagName + "." + attribName + " " + changed, {
                change: changed,
                tagName: tagName,
                attribName: attribName,
                oldValue: oldValue,
                newValue: newValue
            });
        }
    }

    function lookupAttribute(map, tagName, attribName) {
        var attribKey;
        attribKey = tagName + '::' + attribName;
        console.log(attribKey)
        if (map.hasOwnProperty(attribKey)) {
            return map[attribKey];
        }
        attribKey = '*::' + attribName;
        if (map.hasOwnProperty(attribKey)) {
            return map[attribKey];
        }
        return void 0;
    }
    function getAttributeType(tagName, attribName) {
        return lookupAttribute(html4.ATTRIBS, tagName, attribName);
    }
    function getLoaderType(tagName, attribName) {
        return lookupAttribute(html4.LOADERTYPES, tagName, attribName);
    }
    function getUriEffect(tagName, attribName) {
        return lookupAttribute(html4.URIEFFECTS, tagName, attribName);
    }

    /**
     * Sanitizes attributes on an HTML tag.
     * @param {string} tagName An HTML tag name in lowercase.
     * @param {Array.<?string>} attribs An array of alternating names and values.
     * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to
     *     apply to URI attributes; it can return a new string value, or null to
     *     delete the attribute.  If unspecified, URI attributes are deleted.
     * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply
     *     to attributes containing HTML names, element IDs, and space-separated
     *     lists of classes; it can return a new string value, or null to delete
     *     the attribute.  If unspecified, these attributes are kept unchanged.
     * @return {Array.<?string>} The sanitized attributes as a list of alternating
     *     names and values, where a null value means to omit the attribute.
     */
    function sanitizeAttribs(tagName, attribs,
        opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
        // TODO(felix8a): it's obnoxious that domado duplicates much of this
        // TODO(felix8a): maybe consistently enforce constraints like target=
        for (var i = 0; i < attribs.length; i += 2) {
            var attribName = attribs[i];
            var value = attribs[i + 1];
            var oldValue = value;
            var atype = null, attribKey;
            if ((attribKey = tagName + '::' + attribName,
                html4.ATTRIBS.hasOwnProperty(attribKey)) ||
                (attribKey = '*::' + attribName,
                    html4.ATTRIBS.hasOwnProperty(attribKey))) {
                atype = html4.ATTRIBS[attribKey];
            }
            if (atype !== null) {
                switch (atype) {
                    case html4.atype['NONE']: break;
                    case html4.atype['SCRIPT']:
                        value = null;
                        if (opt_logger) {
                            log(opt_logger, tagName, attribName, oldValue, value);
                        }
                        break;
                    case html4.atype['STYLE']:
                        if ('undefined' === typeof parseCssDeclarations) {
                            value = null;
                            if (opt_logger) {
                                log(opt_logger, tagName, attribName, oldValue, value);
                            }
                            break;
                        }
                        var sanitizedDeclarations = [];
                        parseCssDeclarations(
                            value,
                            {
                                'declaration': function (property, tokens) {
                                    var normProp = property.toLowerCase();
                                    sanitizeCssProperty(
                                        normProp, tokens,
                                        opt_naiveUriRewriter
                                            ? function (url) {
                                            return safeUri(
                                                url, html4.ueffects.SAME_DOCUMENT,
                                                html4.ltypes.SANDBOXED,
                                                {
                                                    "TYPE": "CSS",
                                                    "CSS_PROP": normProp
                                                }, opt_naiveUriRewriter);
                                        }
                                            : null);
                                    if (tokens.length) {
                                        sanitizedDeclarations.push(
                                            normProp + ': ' + tokens.join(' '));
                                    }
                                }
                            });
                        value = sanitizedDeclarations.length > 0 ?
                            sanitizedDeclarations.join(' ; ') : null;
                        if (opt_logger) {
                            log(opt_logger, tagName, attribName, oldValue, value);
                        }
                        break;
                    case html4.atype['ID']:
                    case html4.atype['IDREF']:
                    case html4.atype['IDREFS']:
                    case html4.atype['GLOBAL_NAME']:
                    case html4.atype['LOCAL_NAME']:
                    case html4.atype['CLASSES']:
                        value = opt_nmTokenPolicy ? opt_nmTokenPolicy(value) : value;
                        if (opt_logger) {
                            log(opt_logger, tagName, attribName, oldValue, value);
                        }
                        break;
                    case html4.atype['URI']:
                        value = safeUri(value,
                            getUriEffect(tagName, attribName),
                            getLoaderType(tagName, attribName),
                            {
                                "TYPE": "MARKUP",
                                "XML_ATTR": attribName,
                                "XML_TAG": tagName
                            }, opt_naiveUriRewriter);
                        if (opt_logger) {
                            log(opt_logger, tagName, attribName, oldValue, value);
                        }
                        break;
                    case html4.atype['URI_FRAGMENT']:
                        if (value && '#' === value.charAt(0)) {
                            value = value.substring(1);  // remove the leading '#'
                            value = opt_nmTokenPolicy ? opt_nmTokenPolicy(value) : value;
                            if (value !== null && value !== void 0) {
                                value = '#' + value;  // restore the leading '#'
                            }
                        } else {
                            value = null;
                        }
                        if (opt_logger) {
                            log(opt_logger, tagName, attribName, oldValue, value);
                        }
                        break;
                    default:
                        value = null;
                        if (opt_logger) {
                            log(opt_logger, tagName, attribName, oldValue, value);
                        }
                        break;
                }
            } else {
                value = null;
                if (opt_logger) {
                    log(opt_logger, tagName, attribName, oldValue, value);
                }
            }
            attribs[i + 1] = value;
        }
        return attribs;
    }

    /**
     * Creates a tag policy that omits all tags marked UNSAFE in html4-defs.js
     * and applies the default attribute sanitizer with the supplied policy for
     * URI attributes and NMTOKEN attributes.
     * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to
     *     apply to URI attributes.  If not given, URI attributes are deleted.
     * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply
     *     to attributes containing HTML names, element IDs, and space-separated
     *     lists of classes.  If not given, such attributes are left unchanged.
     * @return {function(string, Array.<?string>)} A tagPolicy suitable for
     *     passing to html.sanitize.
     */
    function makeTagPolicy(
        opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
        return function(tagName, attribs) {
            if (!(html4.ELEMENTS[tagName] & html4.eflags['UNSAFE'])) {
                return {
                    'attribs': sanitizeAttribs(tagName, attribs,
                        opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger)
                };
            } else {
                if (opt_logger) {
                    log(opt_logger, tagName, undefined, undefined, undefined);
                }
            }
        };
    }

    /**
     * Sanitizes HTML tags and attributes according to a given policy.
     * @param {string} inputHtml The HTML to sanitize.
     * @param {function(string, Array.<?string>)} tagPolicy A function that
     *     decides which tags to accept and sanitizes their attributes (see
     *     makeHtmlSanitizer above for details).
     * @return {string} The sanitized HTML.
     */
    function sanitizeWithPolicy(inputHtml, tagPolicy) {
        var outputArray = [];
        makeHtmlSanitizer(tagPolicy)(inputHtml, outputArray);
        return outputArray.join('');
    }

    /**
     * Strips unsafe tags and attributes from HTML.
     * @param {string} inputHtml The HTML to sanitize.
     * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to
     *     apply to URI attributes.  If not given, URI attributes are deleted.
     * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply
     *     to attributes containing HTML names, element IDs, and space-separated
     *     lists of classes.  If not given, such attributes are left unchanged.
     */
    function sanitize(inputHtml,
        opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
        var tagPolicy = makeTagPolicy(
            opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger);
        return sanitizeWithPolicy(inputHtml, tagPolicy);
    }

    // Export both quoted and unquoted names for Closure linkage.
    var html = {};
    html.escapeAttrib = html['escapeAttrib'] = escapeAttrib;
    html.makeHtmlSanitizer = html['makeHtmlSanitizer'] = makeHtmlSanitizer;
    html.makeSaxParser = html['makeSaxParser'] = makeSaxParser;
    html.makeTagPolicy = html['makeTagPolicy'] = makeTagPolicy;
    html.normalizeRCData = html['normalizeRCData'] = normalizeRCData;
    html.sanitize = html['sanitize'] = sanitize;
    html.sanitizeAttribs = html['sanitizeAttribs'] = sanitizeAttribs;
    html.sanitizeWithPolicy = html['sanitizeWithPolicy'] = sanitizeWithPolicy;
    html.unescapeEntities = html['unescapeEntities'] = unescapeEntities;
    return html;
})(html4);

var html_sanitize = html['sanitize'];

// Exports for Closure compiler.  Note this file is also cajoled
// for domado and run in an environment without 'window'
if (typeof window !== 'undefined') {
    window['html'] = html;
    window['html_sanitize'] = html_sanitize;
}


// Ensure backwards compatibility
Sanitizer = html;
Sanitizer.escape = html.escapeAttrib;

// the browser, add 'Sanitizer' as a global object via a string identifier,
// for Closure Compiler "advanced" mode.
if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = Sanitizer;
    }
    exports.Sanitizer = Sanitizer;
} else {
    this.Sanitizer = Sanitizer;
}
